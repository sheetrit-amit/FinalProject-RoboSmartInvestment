# -*- coding: utf-8 -*-
"""מודל מרקוביץ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JssWNvFU3AS7S2tLoPQYH3KDivbkh3h5

# ***Loading GCP and tables***
"""

!pip install --quiet google-cloud-bigquery

from google.cloud import bigquery
from google.oauth2 import service_account
import json, os

info = {
  "type": "service_account",
  "project_id": "pro-visitor-429015-f5",
  "private_key_id": "950ceae330f3c4821a2df3243fd787df83d2dcaf",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDLrrndMQpQcrm+\nW7MlNdzUNQWwUonNSoAyhZbR1YwUVS3vCyPqO7JIm1XCfJXc/LexgrTgFNOHkaHo\nmqAS5Imbyjz/vU/xJWxMuiPIjpCZuPL/ZTVkEaY3PGltVi37hJ1lWzWKI4s5YA4V\nuDg11RR6iLAjwSFPfozQmoQ5N41Gn5ptdG6T9HHkit+SumUC2pXiJBqKdYgxtOLx\nSbF/t/Ep2KKLcwYG7bcJCR2FpjgBw/2i8Ntc9z/ga/qcb8I3N+O5oI8j7dhnRuCC\nHSXrjMSsrs6OJRHyYRCaIvAFvbQtDaDfqHnDR52l+aCGn4kOiQGgOQhDMpU52WoY\n6HsW3VLDAgMBAAECggEAAcL8SDhP3Vvt/6z9staGl0PxeCcb761zcrxquQbj+XBh\nKij1Abt2x8pRfBH6yS4FuAsoMwCgcb2QjRlP8B86PMw2KdoX0mn0nVdGJEpuCr5U\nRQw5jCjblgJiQQ1WmXnPU1yYwnNF6tRKBZBnKrlck3tngUT+25f9x3dxVFNcLUkD\n0FlTQK3gE8Sh/KVPn06leq0r6dN7viK9osxknpOCdk/FxRCYS+K9eyJH+2BzXiF+\nVvymQPqUh0WJn+WEJefyZVKXXcTuiqKZGC6DZySkvYfDg9KE2vDKrcTaBcOvlGn8\nA1h6Iw1s78ekGCn0OAXwDaZUuEDxh0FqgclvNZ9ghQKBgQD1DvMYRn4p+EhA/brs\n48wh5CIej+MI0xc37GnZyWXY7pJZJMdHgNH1II8wfDlA0sURdOFnqSzXtVZY2ovz\nC+prHLDyvNNNWssOjzcv6LoVjJ6Ab2rw6AfuMt4Y7YauYZIDEQooSg9PiHeDN2m3\npZZYY2CFZwNZ3MLZyqjrRGiABwKBgQDUxtg6+hQCruTdr0ipv1b2ESJPiCFVKduR\nyQUjrO29YjwWlzUHGEUkWHAWl0S8NXTjFLLVf3nwGeSGsHA/Ijoj9f0TGCjHnMrT\nx5F3tZKuJLqMyF/yxDQfNu44mDvVzS9mG3m+dDlJ4e7dMMdL40T5XON8DCJiMHoa\n8LYxLfKwZQKBgCudTYa0hR/TIIjwn6QpptshTzFBSpb3etppKS2puoaxbzqOYSlI\ntBV8hf+LHGV9HbXNp5Bbe6+ohoWp396R8Fa/9H4/PRw3XIxq0NemA/hx3oPdUJsv\nsLmkNAMbwyymEOaa0cP56l+tWhfwdNBKmEeC6FrVyrLjp4o7l3TH6BFhAoGAG127\nv9IcMsAlxXFe6h4m5B0OCaabiuWITPbKx2zdYuc4jTtDYbc4ZVVOjUlFWOOTNgWa\nfqUXnM7nun8E4MnZKnjf5M3NqOa8m4JmbjwXMnic2bCHzqR3g7A/8V17DKOIPhy4\nistN9vetDhvQ9iyz2VKeG31ACtrrSX2+IRMkzJUCgYEA38BZOERTytgg3jdm1I2v\nHEFpZ1YVlyhZbaCRE+n7ZwUB4RwN0/tfRjo3Qmq1D60I2mToIjE+O9mtsBnq6QBO\nGXV0nSk/6DVdIXJxEqhnQnCKo1vf1aOT+epWtFjFJjKxjULBf+HLujI0ocqxJSY8\nRJH/7QUO+zNHHyWJK9YdWL4=\n-----END PRIVATE KEY-----\n",
  "client_email": "project-api@pro-visitor-429015-f5.iam.gserviceaccount.com",
  "client_id": "117559510697606969089",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/project-api%40pro-visitor-429015-f5.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}


credentials = service_account.Credentials.from_service_account_info(info)

client = bigquery.Client(
    credentials=credentials,
    project=credentials.project_id
)

print("Connected to:", credentials.project_id)

from google.cloud import bigquery
import pandas as pd

table_id = "pro-visitor-429015-f5.StockData.balance_sheets"

query = f"SELECT * FROM `{table_id}`"  # אפשר לשנות את LIMIT לפי הצורך

df = client.query(query).to_dataframe()

print(df.head())

"""# ***mrakowits model***"""

def markowitz_solver(expected_returns, cov_matrix, risk_free_rate=0.02):

    num_assets = len(expected_returns)
    assets_names = expected_returns.index

    # --- Helper Functions ---
    def portfolio_return(weights):
        return np.dot(weights, expected_returns)

    def portfolio_volatility(weights):
        # Calculate Variance
        var = weights.T @ cov_matrix @ weights
        # Prevent negative value in sqrt due to floating point error
        return np.sqrt(max(var, 1e-8))

    def negative_sharpe(weights):
        p_ret = portfolio_return(weights)
        p_vol = portfolio_volatility(weights)
        # Prevent division by zero
        if p_vol < 1e-5: return 0
        return -(p_ret - risk_free_rate) / p_vol

    # --- Solver Settings ---
    constraints = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})
    bounds = tuple((0, 1) for _ in range(num_assets))
    initial_weights = np.array([1/num_assets] * num_assets)

    # --- Execution ---
    result = minimize(
        negative_sharpe,
        initial_weights,
        method='SLSQP',
        bounds=bounds,
        constraints=constraints,
        tol=1e-6
    )

    if not result.success:
        print(f"Optimization failed: {result.message}")
        return None

    optimal_weights = pd.Series(result.x, index=assets_names)
    return optimal_weights[optimal_weights > 0.001].round(4).sort_values(ascending=False)

"""# ***local example***"""

import numpy as np
import pandas as pd
from scipy.optimize import minimize
import warnings
from google.cloud import bigquery
import pandas as pd

table_id = "pro-visitor-429015-f5.StockData.daily_prices"
query = f"""
    SELECT date, ticker, close
    FROM `{table_id}`
    ORDER BY date ASC
"""
df = client.query(query).to_dataframe()
df['date'] = pd.to_datetime(df['date'])

prices = df.pivot_table(index='date', columns='ticker', values='close', aggfunc='mean')

prices = prices.ffill().dropna()

print("--- המימדים של הטבלה המוכנה ---")
print(prices.shape)
print("\n--- 5 השורות הראשונות ---")
print(prices.head())


# Suppress specific RuntimeWarnings from numpy and pandas
warnings.filterwarnings("ignore", category=RuntimeWarning, module='numpy')
warnings.filterwarnings("ignore", category=RuntimeWarning, module='pandas')


# Assuming 'prices' dataframe exists from previous steps

# 1. Save original dimensions
orig_rows, orig_cols = prices.shape
print(f"--- Initial State ---")
print(f"Trading Days: {orig_rows}")
print(f"Assets (Stocks): {orig_cols}")

# 2. Calculate initial returns
returns = prices.pct_change()

# 3. Aggressive Cleaning
# Replace infinite values with NaN
returns.replace([np.inf, -np.inf], np.nan, inplace=True)

# Drop columns (assets) that are entirely empty
returns = returns.dropna(axis=1, how='all')

# Drop rows (days) that have ANY missing data
returns = returns.dropna(axis=0, how='any')

# 4. Save new dimensions
clean_rows, clean_cols = returns.shape

# 5. Cleaning Report
print(f"\n--- Cleaning Report ---")
print(f"Dropped Days (Rows): {orig_rows - clean_rows}")
print(f"Dropped Assets (Columns): {orig_cols - clean_cols}")

print(f"\n--- Final Model State ---")
print(f"Valid Trading Days: {clean_rows}")
print(f"Active Assets: {clean_cols}")

# 1. חישוב תשואות לכל המניות
temp_returns = prices.pct_change().dropna()

# 2. חישוב מדדי ביצוע (תשואה ממוצעת וסטיית תקן)
avg_returns = temp_returns.mean()
std_dev = temp_returns.std()

# 3. חישוב יחס שארפ לכל מניה (תשואה חלקי סיכון)
# (הנחה פשוטה של ריבית חסרת סיכון 0 לצורך הסינון הראשוני)
sharpe_ratios = avg_returns / std_dev

# 4. בחירת 100 הטיקרים עם הציון הגבוה ביותר
top_100_tickers = sharpe_ratios.sort_values(ascending=False).head(250).index

# 5. עדכון ה-DataFrame שיכיל רק אותם
prices_subset = prices[top_100_tickers]

print(f"--- בוצע סינון ---")
print(f"נבחרו {len(top_100_tickers)} מניות עם יחס שארפ הגבוה ביותר.")
print(f"מימדים חדשים למודל: {prices_subset.shape}")

subset_returns = prices_subset.pct_change().dropna()
# 2. חישוב המטריצות על בסיס התשואות (ולא המחירים)
# Annualized Mean Returns
expected_returns = subset_returns.mean() * 252

# Annualized Covariance Matrix
cov_matrix = subset_returns.cov() * 252

# Safety check for remaining NaNs
if expected_returns.isnull().any() or cov_matrix.isnull().values.any():
    print("Warning: NaNs found in matrices. Replacing with 0.")
    expected_returns = expected_returns.fillna(0)
    cov_matrix = cov_matrix.fillna(0)

print("Matrices are ready for calculation.")
print(f"Matrix shape: {cov_matrix.shape}") # וידוא שזה 100 על 100

# הרצת המודל
optimal_portfolio = markowitz_solver(
    expected_returns=expected_returns,
    cov_matrix=cov_matrix,
    risk_free_rate=0.02
)

print("\n--- Optimal Portfolio (Weights) ---")
if optimal_portfolio is not None:
    print(optimal_portfolio)
    print(f"\nTotal assets in portfolio: {len(optimal_portfolio)}")
else:
    print("Solver failed even after fix.")

"""# ***final function to use for n8n***
input- risk_level-

1 High

2	Low

3	Med-High

4	Med-Low

5	Medium

6	Unknown

output- final stock selection
"""

def optimize_portfolio_by_risk(target_risk):
    """
    מקבלת רמת סיכון (למשל 'High', 'Medium', 'Low'),
    מושכת את המניות המתאימות מ-BigQuery, ומחזירה את התיק האופטימלי.
    """
    prices_table = "pro-visitor-429015-f5.StockData.daily_prices"
    risk_table = "pro-visitor-429015-f5.StockData.companies_risk_ratings"

    query = f"""
        SELECT t.date, t.ticker, t.close
        FROM `{prices_table}` t
        INNER JOIN `{risk_table}` r ON t.ticker = r.ticker
        WHERE r.risk_level = '{target_risk}'
        ORDER BY t.date ASC
    """

    print(f"Fetching stocks with Risk Level: '{target_risk}' from BigQuery...")

    df = client.query(query).to_dataframe()

    unique_tickers = df['ticker'].nunique()
    print(f"Found {unique_tickers} stocks matching this risk profile.")

    df['date'] = pd.to_datetime(df['date'])

    prices = df.pivot_table(index='date', columns='ticker', values='close', aggfunc='mean')

    prices = prices.ffill().dropna()

    print(f"Data ready for model. Matrix shape: {prices.shape}")

    returns = prices.pct_change().dropna()

    # # אם יש המון מניות (מעל 100), כדאי לסנן את הטובות ביותר כדי שהמודל ירוץ מהר
    # # (אופציונלי: כאן משולב הסינון לפי שארפ שעשינו קודם)
    # if returns.shape[1] > 100:
    #     print("More than 100 stocks found. Selecting Top 100 by Sharpe Ratio for performance...")
    #     avg_ret = returns.mean()
    #     std_dev = returns.std()
    #     sharpe = avg_ret / std_dev
    #     top_100 = sharpe.sort_values(ascending=False).head(100).index
    #     returns = returns[top_100]
    #     print(f"Filtered down to: {returns.shape}")

    # חישוב שנתי
    expected_returns = returns.mean() * 252
    cov_matrix = returns.cov() * 252

    # בדיקות תקינות
    if expected_returns.isnull().any() or cov_matrix.isnull().values.any():
        print("Warning: NaNs found. Filling with 0.")
        expected_returns = expected_returns.fillna(0)
        cov_matrix = cov_matrix.fillna(0)

    # 4. הפעלת המודל
    # (מניח שהפונקציה markowitz_solver כבר קיימת בזיכרון)
    optimal_portfolio = markowitz_solver(
        expected_returns=expected_returns,
        cov_matrix=cov_matrix,
        risk_free_rate=0.02
    )

    return optimal_portfolio


risk_input = 'High'
portfolio_result = optimize_portfolio_by_risk(risk_input)

print("\n--- Optimized Risk Portfolio ---")
print(portfolio_result)